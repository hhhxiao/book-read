## 高速缓存存储器

### 存储器的层次结构

现代的计算机具有金字塔形的存储器体系结构。从上到下依次是寄存器（CPU内）--> 各级缓存 -->主存（也就是内存）-->本地磁盘-->...

### 高速缓存(cache)

每一层的存储器都能被分成连续的数据对象组块(chunk)，称为块（block）,每个块有唯一的地址或者名字。上一层的缓存中包含着下一层的一个子集的副本（通俗点就是A是B的上一级，A的存储空间小，但是读写速度快，A在任意时刻都有B中的部分数据的备份）。

早期的计算机有三层存储结构：CPU--DRAM--disk,现在因为CPU和内存之间的差距越来越大，系统设计者开示在CPU和内存之间加入小的SRM存储器，称为**L1高速缓存**，后来在L1高速缓存和内存之间出现了L2高速缓存。

> CSAPP下的假设均为只存在一级缓存

### 通用的高速缓存存储器的组织结构

> 这里感觉书也说的不明不白的，可能是翻译问题。

高速缓存由四元组（S,E,B,m）来描述:一共s高速缓存组组，每组E高速缓存行行，每行m个地址位。这些地址位有t位是标记位，有s位是组索引位，有b位是块偏移位。

| 参数          | 描述           |
| ------------- | -------------- |
| S= 2^s        | 组数           |
| E             | 每一组的行数   |
| B = 2^b       | 块的大小       |
| m = log_2^{M} | 物理地址的位数 |

每组只有一行的称为**直接映射高速缓存**

### 缓存命中 

计算机的存储系统有很多级，从上至下一次为第0，1,,,层，当第k层需要数据的时候，它会向第k+1层请求数据，如果该数据正好缓存在k+1层上，则表示**缓存命中**。以CPU为例子，当CPU执行一条读内存的字w的指令的时候，它会先向高速缓存L1请求这刚字，如果高速缓存中有这个字的副本，则说明缓存命中了，如果没有则说明没命中，这时候L1高速缓存要像下一层（也就是内存）请求这个字再交给CPU,这称为**缓存不命中**。

### 缓存如何确定是否命中

1. 组选择，直接根据CPU提供的地址进行索引来选择确定的组
2. 行匹配，高速缓存行中的标记位和地址的标记为匹配则说明缓存命中
3. 字抽取，根据块便宜来索引字再缓存行中的位置

> 有关于CPU具体如何一步一步地命中的细节略去，，暂时看不太懂

### 写命中(write hit)

如果要写的字已经被上一层缓存，称为写命中（write hit）,然后需要做的仅仅是把上一层的数据更新到下一层里面。若发生不命中则有两种方法进行处理：

- 写分配  把数据加载到上一级缓存，然后从缓存写到目的存储器
- 非写分配，直接写到低一级存储器

 ### 真实的缓存结构

缓存中既有可能包含指令，又有可能包含数据。只包含指令的称为**i-cache**，只包含程序数据的称为***d-cache*，两种都包含的称为统一高速缓存。i-cache一般都是只读的。

### 高速缓存参数的性能影响

#### 缓存大小

较大的缓存大小能提高命中率，但是可能会增加命中的时间

#### 块的大小

较大的块能帮助提高命中率，但是对不命中的处罚（不命中的时候浪费的时钟周期）有负面影响。

### 局部性

局部性分为时间局部性和空间局部性

同一个变量能被多次引用则说明时间局部性比较好（声明的变量能重复利用）

本次引用的内存总在下一次的附近说明空间局部性好(不要跨过多的存储器等级)



