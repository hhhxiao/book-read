### 动态链接共享库

为例解决静态链接的缺点出现了共享库（shared library）。共享库也是目标模块，在运行或者加载的时候可以被加载到任意的内存地址，并且可以和一个在内存中的程序链接起来。这个过程称为**动态链接（dynamic linking）**,由一个叫**动态链接器(dynamic linker)**的程序来执行。共享库在`linux`中一般以`.so`作为后缀，在`windows`中以`.dll`作为后缀。

动态链接的一些应用：

- 分发软件，`windows`软件可以通过更新`.dll`文件进行软件更新
- 构建高性能的`web`服务器

### 位置无关代码

为了解决不同的程序调用同一个动态链接库中的代码位置问题，现代系统使用了一种方式来编译共享模块的代码，使得共享的代码段可以被加载到任何位置而无需·1连接器修改。，这样的代码称为**位置无关代码（Position -Independent Code PIC）**，`gcc`的`-fpic`选项1可以指示编译系统生成PIC代码。

- PIC的数据引用

  内存中的代码段中的任何指令和数据段之间的任何变量之间的距离（地址上）都是一个运行时常量（与其绝对位置无关）

  编译器在编译PIC的时候在数据段开始的地方创建了一个全局变量偏移表(GOT),表中记录了全局数据的相关信息，动态链接器会维护这个表来使得它包含正确的绝对地址。

- PIC 函数调用

  GNU编译系统使用了**延迟绑定**技术将函数运行时地址的绑定推迟到第一次调用的时候。（具体工作过程暂且跳过）

### 库打桩机制

Linux链接器支持**库打桩（library interposition）**技术,运行你截获对共享库中函数的调用，用自己的代码取而代之。

应用：

- 追踪特殊库函数的调用次数
- 验证和追踪特殊库函数的输入和输出值

### 一些工具总结

以下工具全部来自于`GNU binutils`工具包

- `ar` 创建静态库，插入，删除，列出和提取成员
- `strings` 列出一个OBJ文件中的所有可打印的字符串
- `strip`从OBJ文件中删除符号表相关信息
- `nm`列出OBJ文件中的符号表定义的符号
- `size`列出OBJ文件中节的名字和大小
- `readelf`显示OBJ文件的完整结构
- `objdump`能显示OBJ文件中的所有信息
- `ldd`列出一个可执行文件在运行时候所需的所有共享

  