### 服务器的三个主要单元

- IO处理单元
  - 四种IO模型和两种高效事件处理方式
- 逻辑单元
  - 高效并发模式和有限状态机
- 存储单元

### 服务器模型

#### CS模型

通信过程中所有的机器都是对等的，但是由于数据提供方的原因，现在几乎所有的网络应用程序都采取了CS模型，也就是`client-server` 模型

服务端创建一个或者多个监听socket,并调用`bind()`函数绑定端口,然后调用`listen`等待用户连接．由于客户端的连接请求是随机到达的**异步事件**，因此服务器需要使用某种`IO`模型来监听这一事件．常见的有`select`IO复用技术．

#### `P2P`模型

`p2p`模型是点对点的模型．

### 服务器编程框架

各个模块的功能描述

- IO处理单元　处理客户连接，读写网络数据

  - 等待并且接受进的客户连接，接收客户数据，把服务器相应返回给客户端

- 逻辑单元　业务进程或者线程

  - 分析并且处理客户数据，把结果返还给io处理单元或者直接发送给客户端

- 网络存储单元　本地数据库，文件缓存

  - 可以是数据库，缓存，文件或者专用的数据服务器等

- 请求队列　各单元之间的通信方式

  - 各单元之间的通信方式的抽象，各个单元之间的通信出现了＂排队＂等情况的时候也需要某种机制来进行协调，我们称这种机制为请求队列


  ### IO模型

  `fcntl()`函数可以改变文件描述符(包括socket)的性质,其中一个参数可以更改文件描述符为阻塞IO还是非阻塞IO.

  针对阻塞io执行的系统调用可能因为操作无法立即完成而被操作系统**挂起**，直到等到事件发生为止．

  针对非阻塞的IO执行的系统调用总是１立即返回，要么成功要么失败返回-1并且设置`errno`

  非阻塞IO通常和各种IO通知技术一起使用，比如**IO复用技术**常用的复用技术有`select`和`epoll`

  阻塞IO,IO复用，信号驱动IO都是**同步IO**模型，因为这些模型中，**读写操作总是在IO事件发生后执行**．另一种IO是异步IO,不是这本书的重点．



### 两种高效的事件处理模式

- Reactor 一般用同步IO来实现
- Proactor 一般用异步IO来实现

#### Reactor

该模式要求主线程只负责监听文件描述符上是否有事件发生，有的话就立刻把该事件通知到工作线程，除此之外主线程不做其他实质性的工作．

#### Proactor

该模式把所有的IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑

> 使用`epoll_wait()`实现和模拟的两周诗经处理模型暂时跳过，学了`epoll()`再看

### 两种高效的并发模式

并发处理模式指的是IO处理单元和多高逻辑单元之间协调完成任务的方法．服务器主要有**半同步／办异步模式**和**领导者／追随者模式**

#### 半同步／半异步模式

并发模式中的＂同步＂指的是程序完全按照代码序列的顺序执行;＂异步＂指的是程序的执行需要由系统事件来驱动，如中断，信号等等．

按照同步方式运行的线程称之为同步线程，按照异步方式运行的线程称之为异步线程．

服务器程序中这两种都需要，即采用**半同步半异步**模式来实现．其中同步线程用来处理客户逻辑，异步线程用来处理IO事件．

#### 领导者和追随者模式

领导者追随者模式是多个工作线程轮流获得事件集合，轮流监听，分发并处理事件的一中

领导者／追随者模式的组件：

- 句柄集　用于表示IO资源，也就是一堆文件描述符的集合
- 线程集　是所有工作线程的管理者，负责各个线程之间的同步以及新领导线程的推选
- 事件处理器　
- 具体事件处理器

### 有限状态机

(略)

### 其他建议

- 池
- 数据复制
- 上下文切换和锁