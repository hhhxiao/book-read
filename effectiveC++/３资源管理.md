## 13. 用对象管理资源

- 获得资源的时候应该立即放入管理对象（managing object）内．比较保险的做法是把动态申明的对象指针交付给智能指针对象管理，这样不同担心释放问题：（书中的`auto_ptr`已经过时，不使用，而是使用`RCSP`,也就是`shared_ptr<>`）[**RARII**]

  ```c++
  std::shared_ptr<A> a_ptr(new A());
  ```

- 应利用析构函数来释放相关内存

- 智能指针类不应该用来管理数组类的动态分配内存（因为其内部调用的是`delete`而不是`delete[]`）,不仅如此应使用STL的容器类来代替动态分配的数组，`Boost`库提供了对于动态数组的智能指针，这里不过多介绍

## 14.在资源管理类中小心`copy`行为

以下两种策略用来应对管理者的**复制**行为：

- 禁止复制行为：声明私有的拷贝构造操作

- 对底层资源使用引用计数，复制行为只复制引用而不复制资源，然后加一个引用计数，类似`shared_ptr`，当引用计数为0的时候销毁资源

- 不只是引用，底层资源也要进行复制，即所谓的**深拷贝**
- 转移底部资源的拥有权

