## 13. 用对象管理资源

- 获得资源的时候应该立即放入管理对象（managing object）内．比较保险的做法是把动态申明的对象指针交付给智能指针对象管理，这样不同担心释放问题：（书中的`auto_ptr`已经过时，不使用，而是使用`RCSP`,也就是`shared_ptr<>`）[**RARII**]

  ```c++
  std::shared_ptr<A> a_ptr(new A());
  ```

- 应利用析构函数来释放相关内存

- 智能指针类不应该用来管理数组类的动态分配内存（因为其内部调用的是`delete`而不是`delete[]`）,不仅如此应使用STL的容器类来代替动态分配的数组，`Boost`库提供了对于动态数组的智能指针，这里不过多介绍

## 14.在资源管理类中小心`copy`行为

以下两种策略用来应对管理者的**复制**行为：

- 禁止复制行为：声明私有的拷贝构造操作

- 对底层资源使用引用计数，复制行为只复制引用而不复制资源，然后加一个引用计数，类似`shared_ptr`，当引用计数为0的时候销毁资源

- 不只是引用，底层资源也要进行复制，即所谓的**深拷贝**
- 转移底部资源的拥有权

## 15. 在资源管理类中提供对原始资源的访问

资源管理类是很好的对抗资源泄露的**壁垒**.但是这个壁垒也导致了缺点的产生，为了消除这些缺点，产生了以下两条设计原则

- `API`往往要求访问原始资源的方法，因此资源管理类应该提供原始资源的访问接口
- 对原始资源的访问会经过隐式访问或者显示访问，这两者各有优缺点，应合理使用

## `16.成对使用`new`和`delete`的时候要采取相同的形式

- 动态分配的数组内存时,应用`delete []` 来删除
- 不是使用的数组内存的时候,应直接用`delete`删除

## 17. 以独立语句把`newed`对象放入智能指针

不要这么写:

```c++
fun(std::shaered_ptr<A>(new A),xx);
```

而要这么写:

```c++
auto ptr = std::shared_ptr<A>(new A );
fun(ptr,xx);
```

第一种写法可能会有内存泄漏,???