## 5.了解C++默默编写并构造哪些函数

自己没有声明编译器自动构造的函数：

- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数
- 默认构造函数

## 6.若不想使用编译器提供的默认函数应该明确拒绝

可以自行定义未实现的私有相关函数来阻止默认的相关函数的生成

```c++
class A{
private:
    A(const A& a);
};
//main
A a;
A b(a);//error
```

C++11以及以后可直接使用`=delete`：表示不使用编译器提供的默认函数

```c++
class A{
public：
	A()=delete;
}
```

## 7. 为多态基类声明`virtual`析构函数

对于如下的指向派生类对象的基类指针：

```C++
Base *ptr = new Derived();
```

如果`Base`中的析构函数没有声明为`virtual`的则可能在`delete ptr`的操作中只销毁该对象的基类部分，而没有销毁派生的部分。

解决方法是**基类使用虚析构函数**：

```c++
virtual ~Base(){//todo
}
```

一个类中若有虚析够函数，则其对象的大小会增加，因此为了避免产生不必要的麻烦，**非基类不应该添加虚析够函数**

或者说：

- **当class内至少有一个virtual成员函数时，才为其声明虚析构函数**
- **不要去继承一个没有虚析构函数的类**

## 8. 别让异常逃离析构函数

##　9. 不在构造和析构函数中调用（纯）虚函数

在调用派生类的析构函数的时候会首先调用基类的构造函数，如果基类的构造函数中有（纯）虚函数，则会引发**未定义行为**,析构函数也是如此，像这样的直接调用会被编译器侦测到，但是间接调用带`virtual`的函数的时候，编译器则显得很无力．

## 10.　令`operator=`返回一个`*this`的引用

```c++
class A{
  //
    //重载复制运算符
    A& operator=(const A& a){
        //todo
        return*this;
    }
    //重载 +=
    A& operator+=(const A& a){
        //todo
        return *this;
    }
};
```

## 11. 在`operator=`中处理自我赋值

在某些类（比如成员变量具有指针）中`operator=()`的实现中应加上自我赋值检测：

```c++
if(this == &rhs)return *this;
```

但是加上上面的代码后虽具有"自我赋值安全性"但仍然不具备"异常安全性"（在极少数情况下会出问题）

正确的姿势：`copy and swap`

```c++
A &operator=(const & rhs){
	A temp(rhs);
    swap(temp); //swap见条款29
    return *this;
}
```

- 在操作多个对象的时候要考虑这多个对象是同一个对象的情形

## 12. 复制对象勿忘其每一个成分

- 派生类写拷贝构造函数的时候应调用基类的拷贝构造函数
- 要复制所有的（非静态）成员变量