> 对应C++ primer 的CH13

## 拷贝控制

### 拷贝，赋值与销毁

#### 拷贝构造函数(The Copy Constructor)

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则称此构造函数为**拷贝构造函数**，通常情况下，拷贝构造函数是被**隐式调用**的。

```c++
class A{
A(const A & a){
}//一个拷贝构造函数
}
```

没有显示定义拷贝构造函数时候，编译器会为自动合成(synthesizes)一个拷贝构造函数。因此不管有没有自定义拷贝构造函数,下面的代码总是能顺利通过编译：

```c++
A a;
A b(a);
A c = a;
```

拷贝构造发生在以下几种情况：

- 用`=`定义变量的时候（**是定义不是赋值**)
- 发生非引用的参数传递的时候
- 返回非引用类型的返回值的时候
- 用花括号初始化一个数组中的愿誓死或者一个聚合类中的成员

```c++
A a;
A a = b;//调用拷贝构造函数
A c;
c = b;//这里是重载运算符，而不调用拷贝构造函数

A fun(A a){//传参的时候会调用拷贝构造函数
    A b;
    return b;//返回非引用的时候会调用拷贝构造函数
}
```

> 拷贝构造函数必须传引用类型不然会陷入一个传参过程的死循环

#### 拷贝赋值运算符(copy-assignment operator)

> 类可以控制对象如何初始化，也能控制对象如何赋值,这一行为通过定义拷贝赋值运算符来实现

如果类的设计者未自定义拷贝赋值运算符，编译器也会为其合成(synthesize)一个。

```C++
A & operator=(const A &a){
	//todo
    return *this;//返回一个此对象的引用，相当于是根据传入对象的值来修改当前对象
}
```

#### 自定义函数的需求分析

> 对析构函数的需求比对拷贝构造函数和拷贝赋值运算符的需求更为明显，如果一个类需要析构函数，那么我们几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符

#### 阻止拷贝(Preventing Copies)

可以将拷贝构造函数和拷贝赋值运算符定义为函数的函数(deleted funcion)来阻止拷贝：

```c++
 A (const A & a)= delete;//阻止拷贝
 A & operator=(const A & a) = delete;//阻止赋值
```

正因为如此,这样的代码

```c++
std::istream o = std::cin;
```

和把std::cin直接作为非引用传递是万万不可的。

### 拷贝控制和资源管理

#### 类的行为

有的类的行为像值——当拷贝一个对象的时候副本和原来的对象使用完全不相干的底层数据，没有任何的联系，如`std::string`

有的类的行为像指针——副本和原对象都维护着同一块内存，它们有着十分强的关联,如`shared_ptr`.

#### 行为像值的类

##### 赋值的过程

重载赋值运算符的时候必须考虑如下几点：

- 如果将一个对象赋值给本身，要确保这个运算符能正常工作
- 赋值过程中包含拷贝构造和析构的过程，构造和析构的过程没处理好可能会释放不该释放的内存

> 一个好的习惯是：先`=`把右侧的对象拷贝到一个临时的局部对象中，拷贝完成后再把临时对象赋值给新对象

#### 行为像指针的类

！等到看了智能指针再回头看这一节

### 交换操作(swap operation)

```c++
void swap(A &a,A & b){
//todo
}
```

`swap()`要保证a，b是同一个对象的时候不出现问题且尽量少地进行拷贝复制。

### 对象移动（object moving）

#### 右值引用（rvalue referrence）

为了支持移动操作，新标准引用了一种新的引用称之为右值引用(仅仅为了区分左值引用).右值引用可以绑定到字面常量，返回右值的表达式等上。

##### 左值和右值的区别

左值具有持久的状态，右值要么是字面量，要么是表达式求值过程中产生的临时量

> 右值引用指向即将被销毁对象

##### 变量是左值

```c++
int a = 1;
int &&b = 1;//右值引用到字面量1
int &&c = a;//错误，不能右值引用到左值a
int &&d = a+1;//正确，右边的表达式就是字面量2
```

变量是左值，因此不能把一个右值引用绑定到一个变量上

##### `move`函数

位于`utility`下的`std::move()`函数能返回给定对象的右值引用[??]

```c++
int a = 1;
int &&b = std::move(a);
```

#### 移动构造函数和移动赋值运算符

```c++
A(A && a)noexcept//向编译器保证不抛出异常
{
//this对象接管a中的内存资源
    //置于可析构状态(基本类型成员则不需要该操作)
    a.a = nullptr;
    a.xxx = nullptr;
}

A & operator=(A && oa)noexcept
{
    if(this != &oa)//如果不是同一个对象
    {
        //释放已有的内存
        //接管oa的内存
		//把oa置于可析构状态            
    }
    
}
```

> 不抛出异常的移动构造函数和移动复制运算符必须标记为noexcept

#### 对比

拷贝构造函数和移动构造函数的不同仅仅在于传入的值一个是左值引用，一个是右值引用，因为左值引用的对象是持久存在的，因为我们只是执行“复制”操作，而不能对传入的左值引用造成影响。相反，右值引用是“不稳定的，不能持久存在的”，相当于在这块内存“死掉”前夕把它“窃取”过来，之后还要保证这块内存能够安稳地“死去”（被析构）。拷贝和移动构造函数的使用增大了参数的传递范围。这一过程可以扩展到其它普通的成员函数上，也就是相关函数提供左值传递和右值传递两个版本。