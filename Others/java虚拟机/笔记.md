## java的内存区域和内存溢出异常

### **运行时**数据区域

java虚拟机所管理的内存会包括以下几个运行时数据区域

![](C:\Users\AgNO3\Desktop\深入理解java虚拟机\2-1.png)

下面是分别的介绍：

#### 程序计数器(Program Counter Register)

是**当前线程**所执行的字节码行号指示器,每条线程都有独立的程序计数器，程序计数器是**线程私有**的内存

- 当线程在执行java方法时候，计数器记录的是虚拟机字节码指令的地址
- 当执行的是Native方法时，该计数器为空

程序计数器所在内存区不会发生`OutOfMemoryError`

#### java虚拟机栈（JVM stacks）

java虚拟机栈也是**线程私有**的。

> 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧**（Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

#####  局部变量表

虚拟机栈中存在**局部变量表**，局部变量表保存了编译期可知的各种基本数据类型,**对象引用（reference）**在这之中`long`和`double`会占用两个局部变量空间，其它的类型占两个。

##### 虚拟机栈中的异常

- `StackOverflowError`线程请求的栈深度大于虚拟机允许的深度

- `OutOfMemoryError`：虚拟机动态扩展时候无法申请到足够的内存

#### 本地方法栈（Native Method Stack）

为虚拟机使用到的native方法服务

##### 本地方法栈中的异常

- `StackOverflowError`

- `OutOfMemoryError`

#### java 堆（java heap）

java堆是java虚拟机所管理的内存中最大的一块，**java的堆区被所有的线程共享**，该内存的作用就是**存放对象实例**

>所有的对象实例以及数组都要在堆上分配

java堆是**垃圾收集器**的主要管理区域，因此也叫"GC堆"

从内存回收的角度上看，java堆可以分为：

- 新生代
- 老年代

从内存的分配角度上来看，线程共享的java堆中能划分出多个**线程私有**的分配缓冲区(TLAB)

当堆中没有完成内存分配，堆也无法再扩展的时候会抛出`OutOfMemory`异常

#### 方法区（Method Area）

方法区也是**线程共享**的。用于储存已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

方法区也成为`Non-Heap`或者`永生代`

##### 运行时常量池（runtime constant pool）

运行时常量池是方法区的一部分

#### 直接内存(direct memory)



### `HotSpot`虚拟机对象探秘

#### 对象的创建过程

- 类加载检查
- 内存分配，有**指针碰撞**和**空闲列表**法
- 把分配到的内存空间初始化为0值
- 对对象进行必要的设置（包括一些操作和`<init>`方法）

#### 对象的内存布局

对象在内存中的布局可以分为三块区域：

- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Padding）

对象头分为两部分：

- 第一部分用来存储对象自身的运行数据（哈希码，锁状态标志等），在32位和64位的虚拟机中大小位32bit和64bit
- 第二部分是**类型指针**，也就是对象指向它的类元数据的指针，**虚拟机通过这个指针来确定这个对象是哪个类的实例**

实例数据就是在程序代码中定义的各种类型字段的真实信息

#### 对象的访问定位

在对象被创建后，java程序需要通过栈上的`reference`来操作堆上的具体对象，这一操作一般有两种访问方式o，各有优劣：

- 句柄访问
- 直接指针访问



## 垃圾收集器与内存分配策略

>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。

### 垃圾收集（garbage collection，GC）

需要完成的三件事情

- 那些内存需要回收
- 在什么时候回收
- 该如何回收

### 对象已死吗

#### 引用计数算法

> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的

优点：实现简单，判断效率高，大部分情况下是一个不错的算法

缺点：无法解决对象之间**循环引用**的问题,因此并不适用与jvm

#### 可达性分析算法(Reachability Analysis)

>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

可以作为GC Root对象的有以下几种：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

#### 引用(refernence)

引用的分类：

- 强引用：在代码中普遍存在的，类似`Object o = new Object()`的引用，只要强引用还在，垃圾收集器就不会回收被引用的对象
- 软引用：用来描述还有用但并非必须的对象，内存不足时候会对软引用的对象进行二次回收
- 弱引用：用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- 虚引用

#### 生存还是死亡

宣告一个对象的死亡至少需要经过两次标记过程

> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

##  后面有点看不太懂了

...